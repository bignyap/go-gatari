// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_usage_summary.sql

package sqlcgen

import (
	"context"
)

type CreateApiUsageSummariesParams struct {
	UsageStartDate int32
	UsageEndDate   int32
	TotalCalls     int32
	TotalCost      float64
	SubscriptionID int32
	ApiEndpointID  int32
	OrganizationID int32
}

const createApiUsageSummary = `-- name: CreateApiUsageSummary :one
INSERT INTO api_usage_summary (
    usage_start_date, usage_end_date, total_calls,
    total_cost, subscription_id, api_endpoint_id, 
    organization_id
) 
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING usage_summary_id
`

type CreateApiUsageSummaryParams struct {
	UsageStartDate int32
	UsageEndDate   int32
	TotalCalls     int32
	TotalCost      float64
	SubscriptionID int32
	ApiEndpointID  int32
	OrganizationID int32
}

func (q *Queries) CreateApiUsageSummary(ctx context.Context, arg CreateApiUsageSummaryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createApiUsageSummary,
		arg.UsageStartDate,
		arg.UsageEndDate,
		arg.TotalCalls,
		arg.TotalCost,
		arg.SubscriptionID,
		arg.ApiEndpointID,
		arg.OrganizationID,
	)
	var usage_summary_id int32
	err := row.Scan(&usage_summary_id)
	return usage_summary_id, err
}

const getApiUsageSummaryByEndpointId = `-- name: GetApiUsageSummaryByEndpointId :many
SELECT usage_summary_id, usage_start_date, usage_end_date, total_calls, total_cost, subscription_id, api_endpoint_id, organization_id FROM api_usage_summary
WHERE api_endpoint_id = $1
LIMIT $2 OFFSET $3
`

type GetApiUsageSummaryByEndpointIdParams struct {
	ApiEndpointID int32
	Limit         int32
	Offset        int32
}

func (q *Queries) GetApiUsageSummaryByEndpointId(ctx context.Context, arg GetApiUsageSummaryByEndpointIdParams) ([]ApiUsageSummary, error) {
	rows, err := q.db.Query(ctx, getApiUsageSummaryByEndpointId, arg.ApiEndpointID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiUsageSummary{}
	for rows.Next() {
		var i ApiUsageSummary
		if err := rows.Scan(
			&i.UsageSummaryID,
			&i.UsageStartDate,
			&i.UsageEndDate,
			&i.TotalCalls,
			&i.TotalCost,
			&i.SubscriptionID,
			&i.ApiEndpointID,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiUsageSummaryByOrgId = `-- name: GetApiUsageSummaryByOrgId :many
SELECT usage_summary_id, usage_start_date, usage_end_date, total_calls, total_cost, subscription_id, api_endpoint_id, organization_id FROM api_usage_summary
WHERE subscription_id IN (
    SELECT subscription_id FROM subscription s
    WHERE s.organization_id = $1
)
LIMIT $2 OFFSET $3
`

type GetApiUsageSummaryByOrgIdParams struct {
	OrganizationID int32
	Limit          int32
	Offset         int32
}

func (q *Queries) GetApiUsageSummaryByOrgId(ctx context.Context, arg GetApiUsageSummaryByOrgIdParams) ([]ApiUsageSummary, error) {
	rows, err := q.db.Query(ctx, getApiUsageSummaryByOrgId, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiUsageSummary{}
	for rows.Next() {
		var i ApiUsageSummary
		if err := rows.Scan(
			&i.UsageSummaryID,
			&i.UsageStartDate,
			&i.UsageEndDate,
			&i.TotalCalls,
			&i.TotalCost,
			&i.SubscriptionID,
			&i.ApiEndpointID,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiUsageSummaryBySubId = `-- name: GetApiUsageSummaryBySubId :many
SELECT usage_summary_id, usage_start_date, usage_end_date, total_calls, total_cost, subscription_id, api_endpoint_id, organization_id FROM api_usage_summary
WHERE subscription_id = $1
LIMIT $2 OFFSET $3
`

type GetApiUsageSummaryBySubIdParams struct {
	SubscriptionID int32
	Limit          int32
	Offset         int32
}

func (q *Queries) GetApiUsageSummaryBySubId(ctx context.Context, arg GetApiUsageSummaryBySubIdParams) ([]ApiUsageSummary, error) {
	rows, err := q.db.Query(ctx, getApiUsageSummaryBySubId, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiUsageSummary{}
	for rows.Next() {
		var i ApiUsageSummary
		if err := rows.Scan(
			&i.UsageSummaryID,
			&i.UsageStartDate,
			&i.UsageEndDate,
			&i.TotalCalls,
			&i.TotalCost,
			&i.SubscriptionID,
			&i.ApiEndpointID,
			&i.OrganizationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementUsage = `-- name: IncrementUsage :exec
INSERT INTO api_usage_summary (
  usage_start_date, usage_end_date, total_calls, total_cost,
  subscription_id, api_endpoint_id, organization_id
)
VALUES (
  FLOOR(EXTRACT(EPOCH FROM now())/60)*60,
  FLOOR(EXTRACT(EPOCH FROM now())/60)*60 + 59,
  1, 0.0, $1, $2, $3
)
ON CONFLICT (usage_start_date, usage_end_date, api_endpoint_id, organization_id)
DO UPDATE SET total_calls = api_usage_summary.total_calls + 1
`

type IncrementUsageParams struct {
	SubscriptionID int32
	ApiEndpointID  int32
	OrganizationID int32
}

func (q *Queries) IncrementUsage(ctx context.Context, arg IncrementUsageParams) error {
	_, err := q.db.Exec(ctx, incrementUsage, arg.SubscriptionID, arg.ApiEndpointID, arg.OrganizationID)
	return err
}
