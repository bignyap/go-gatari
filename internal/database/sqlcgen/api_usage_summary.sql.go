// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_usage_summary.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type CreateApiUsageSummariesParams struct {
	UsageStartDate int32   `json:"usage_start_date"`
	UsageEndDate   int32   `json:"usage_end_date"`
	TotalCalls     int32   `json:"total_calls"`
	TotalCost      float64 `json:"total_cost"`
	SubscriptionID int32   `json:"subscription_id"`
	ApiEndpointID  int32   `json:"api_endpoint_id"`
	OrganizationID int32   `json:"organization_id"`
}

const createApiUsageSummary = `-- name: CreateApiUsageSummary :one
INSERT INTO api_usage_summary (
    usage_start_date, usage_end_date, total_calls,
    total_cost, subscription_id, api_endpoint_id, 
    organization_id
) 
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING usage_summary_id
`

type CreateApiUsageSummaryParams struct {
	UsageStartDate int32   `json:"usage_start_date"`
	UsageEndDate   int32   `json:"usage_end_date"`
	TotalCalls     int32   `json:"total_calls"`
	TotalCost      float64 `json:"total_cost"`
	SubscriptionID int32   `json:"subscription_id"`
	ApiEndpointID  int32   `json:"api_endpoint_id"`
	OrganizationID int32   `json:"organization_id"`
}

func (q *Queries) CreateApiUsageSummary(ctx context.Context, arg CreateApiUsageSummaryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createApiUsageSummary,
		arg.UsageStartDate,
		arg.UsageEndDate,
		arg.TotalCalls,
		arg.TotalCost,
		arg.SubscriptionID,
		arg.ApiEndpointID,
		arg.OrganizationID,
	)
	var usage_summary_id int32
	err := row.Scan(&usage_summary_id)
	return usage_summary_id, err
}

const getUsageSummary = `-- name: GetUsageSummary :many
WITH filtered_usage AS (
  SELECT organization_id, subscription_id, api_endpoint_id,
  SUM(total_calls) AS total_calls,
  SUM(total_cost) AS total_cost
  FROM api_usage_summary
  WHERE 
    ($1::int IS NULL OR organization_id = $1) AND
    ($2::int IS NULL OR subscription_id = $2) AND
    ($3::int IS NULL OR api_endpoint_id = $3) AND
    ($4::int IS NULL OR usage_start_date >= $4) AND
    ($5::int IS NULL OR usage_end_date <= $5)
  GROUP BY organization_id, subscription_id, api_endpoint_id
  LIMIT $7 OFFSET $6
)
SELECT 
  f.organization_id,
  org.organization_name,
  f.subscription_id,
  sub.subscription_name,
  f.api_endpoint_id,
  ae.endpoint_name,
  f.total_calls,
  f.total_cost
FROM filtered_usage f
JOIN api_endpoint ae ON f.api_endpoint_id = ae.api_endpoint_id
JOIN subscription sub ON f.subscription_id = sub.subscription_id
JOIN organization org ON f.organization_id = org.organization_id
`

type GetUsageSummaryParams struct {
	OrgID      pgtype.Int4 `json:"org_id"`
	SubID      pgtype.Int4 `json:"sub_id"`
	EndpointID pgtype.Int4 `json:"endpoint_id"`
	StartDate  pgtype.Int4 `json:"start_date"`
	EndDate    pgtype.Int4 `json:"end_date"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type GetUsageSummaryRow struct {
	OrganizationID   int32  `json:"organization_id"`
	OrganizationName string `json:"organization_name"`
	SubscriptionID   int32  `json:"subscription_id"`
	SubscriptionName string `json:"subscription_name"`
	ApiEndpointID    int32  `json:"api_endpoint_id"`
	EndpointName     string `json:"endpoint_name"`
	TotalCalls       int64  `json:"total_calls"`
	TotalCost        int64  `json:"total_cost"`
}

func (q *Queries) GetUsageSummary(ctx context.Context, arg GetUsageSummaryParams) ([]GetUsageSummaryRow, error) {
	rows, err := q.db.Query(ctx, getUsageSummary,
		arg.OrgID,
		arg.SubID,
		arg.EndpointID,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageSummaryRow{}
	for rows.Next() {
		var i GetUsageSummaryRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.OrganizationName,
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.ApiEndpointID,
			&i.EndpointName,
			&i.TotalCalls,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageSummaryGroupedByDay = `-- name: GetUsageSummaryGroupedByDay :many
WITH filtered_usage AS (
  SELECT organization_id, subscription_id, api_endpoint_id,
  EXTRACT(YEAR FROM TO_TIMESTAMP(usage_start_date))::INT AS usage_year,
  EXTRACT(MONTH FROM TO_TIMESTAMP(usage_start_date))::INT AS usage_month,
  EXTRACT(DAY FROM TO_TIMESTAMP(usage_start_date))::INT AS usage_day,
  SUM(total_calls) AS total_calls,
  SUM(total_cost) AS total_cost
  FROM api_usage_summary
  WHERE 
    ($1::int IS NULL OR organization_id = $1) AND
    ($2::int IS NULL OR subscription_id = $2) AND
    ($3::int IS NULL OR api_endpoint_id = $3) AND
    ($4::int IS NULL OR usage_start_date >= $4) AND
    ($5::int IS NULL OR usage_end_date <= $5)
  GROUP BY usage_year, usage_month, usage_day, organization_id, subscription_id, api_endpoint_id
  LIMIT $7 OFFSET $6
)
SELECT 
  f.organization_id,
  org.organization_name,
  f.subscription_id,
  sub.subscription_name,
  f.api_endpoint_id,
  ae.endpoint_name,
  f.usage_year,
  f.usage_month,
  f.usage_day,
  f.total_calls,
  f.total_cost
FROM filtered_usage f
JOIN api_endpoint ae ON f.api_endpoint_id = ae.api_endpoint_id
JOIN subscription sub ON f.subscription_id = sub.subscription_id
JOIN organization org ON f.organization_id = org.organization_id
ORDER BY usage_year DESC, usage_month DESC, usage_day DESC
`

type GetUsageSummaryGroupedByDayParams struct {
	OrgID      pgtype.Int4 `json:"org_id"`
	SubID      pgtype.Int4 `json:"sub_id"`
	EndpointID pgtype.Int4 `json:"endpoint_id"`
	StartDate  pgtype.Int4 `json:"start_date"`
	EndDate    pgtype.Int4 `json:"end_date"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type GetUsageSummaryGroupedByDayRow struct {
	OrganizationID   int32  `json:"organization_id"`
	OrganizationName string `json:"organization_name"`
	SubscriptionID   int32  `json:"subscription_id"`
	SubscriptionName string `json:"subscription_name"`
	ApiEndpointID    int32  `json:"api_endpoint_id"`
	EndpointName     string `json:"endpoint_name"`
	UsageYear        int32  `json:"usage_year"`
	UsageMonth       int32  `json:"usage_month"`
	UsageDay         int32  `json:"usage_day"`
	TotalCalls       int64  `json:"total_calls"`
	TotalCost        int64  `json:"total_cost"`
}

func (q *Queries) GetUsageSummaryGroupedByDay(ctx context.Context, arg GetUsageSummaryGroupedByDayParams) ([]GetUsageSummaryGroupedByDayRow, error) {
	rows, err := q.db.Query(ctx, getUsageSummaryGroupedByDay,
		arg.OrgID,
		arg.SubID,
		arg.EndpointID,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageSummaryGroupedByDayRow{}
	for rows.Next() {
		var i GetUsageSummaryGroupedByDayRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.OrganizationName,
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.ApiEndpointID,
			&i.EndpointName,
			&i.UsageYear,
			&i.UsageMonth,
			&i.UsageDay,
			&i.TotalCalls,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementUsage = `-- name: IncrementUsage :exec
INSERT INTO api_usage_summary (
  usage_start_date, usage_end_date, total_calls, total_cost,
  subscription_id, api_endpoint_id, organization_id
)
VALUES (
  FLOOR(EXTRACT(EPOCH FROM now())/60)*60,
  FLOOR(EXTRACT(EPOCH FROM now())/60)*60 + 59,
  1, 0.0, $1, $2, $3
)
ON CONFLICT (usage_start_date, usage_end_date, api_endpoint_id, organization_id)
DO UPDATE SET total_calls = api_usage_summary.total_calls + 1
`

type IncrementUsageParams struct {
	SubscriptionID int32 `json:"subscription_id"`
	ApiEndpointID  int32 `json:"api_endpoint_id"`
	OrganizationID int32 `json:"organization_id"`
}

func (q *Queries) IncrementUsage(ctx context.Context, arg IncrementUsageParams) error {
	_, err := q.db.Exec(ctx, incrementUsage, arg.SubscriptionID, arg.ApiEndpointID, arg.OrganizationID)
	return err
}
