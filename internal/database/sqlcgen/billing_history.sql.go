// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_history.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type CreateBillingHistoriesParams struct {
	BillingStartDate int32       `json:"billing_start_date"`
	BillingEndDate   int32       `json:"billing_end_date"`
	TotalAmountDue   float64     `json:"total_amount_due"`
	TotalCalls       int32       `json:"total_calls"`
	PaymentStatus    string      `json:"payment_status"`
	PaymentDate      pgtype.Int4 `json:"payment_date"`
	BillingCreatedAt int32       `json:"billing_created_at"`
	SubscriptionID   int32       `json:"subscription_id"`
}

const createBillingHistory = `-- name: CreateBillingHistory :one
INSERT INTO billing_history (
    billing_start_date, billing_end_date, total_amount_due,
    total_calls, payment_status, payment_date, 
    billing_created_at, subscription_id
) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING billing_id
`

type CreateBillingHistoryParams struct {
	BillingStartDate int32       `json:"billing_start_date"`
	BillingEndDate   int32       `json:"billing_end_date"`
	TotalAmountDue   float64     `json:"total_amount_due"`
	TotalCalls       int32       `json:"total_calls"`
	PaymentStatus    string      `json:"payment_status"`
	PaymentDate      pgtype.Int4 `json:"payment_date"`
	BillingCreatedAt int32       `json:"billing_created_at"`
	SubscriptionID   int32       `json:"subscription_id"`
}

func (q *Queries) CreateBillingHistory(ctx context.Context, arg CreateBillingHistoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBillingHistory,
		arg.BillingStartDate,
		arg.BillingEndDate,
		arg.TotalAmountDue,
		arg.TotalCalls,
		arg.PaymentStatus,
		arg.PaymentDate,
		arg.BillingCreatedAt,
		arg.SubscriptionID,
	)
	var billing_id int32
	err := row.Scan(&billing_id)
	return billing_id, err
}

const getBillingHistoryById = `-- name: GetBillingHistoryById :many
SELECT billing_id, billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id FROM billing_history
WHERE billing_id = $1
LIMIT $2 OFFSET $3
`

type GetBillingHistoryByIdParams struct {
	BillingID int32 `json:"billing_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetBillingHistoryById(ctx context.Context, arg GetBillingHistoryByIdParams) ([]BillingHistory, error) {
	rows, err := q.db.Query(ctx, getBillingHistoryById, arg.BillingID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingHistory{}
	for rows.Next() {
		var i BillingHistory
		if err := rows.Scan(
			&i.BillingID,
			&i.BillingStartDate,
			&i.BillingEndDate,
			&i.TotalAmountDue,
			&i.TotalCalls,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.BillingCreatedAt,
			&i.SubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBillingHistoryByOrgId = `-- name: GetBillingHistoryByOrgId :many
SELECT billing_id, billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id FROM billing_history
WHERE subscription_id IN (
    SELECT subscription_id FROM subscription
    WHERE organization_id = $1
)
LIMIT $2 OFFSET $3
`

type GetBillingHistoryByOrgIdParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) GetBillingHistoryByOrgId(ctx context.Context, arg GetBillingHistoryByOrgIdParams) ([]BillingHistory, error) {
	rows, err := q.db.Query(ctx, getBillingHistoryByOrgId, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingHistory{}
	for rows.Next() {
		var i BillingHistory
		if err := rows.Scan(
			&i.BillingID,
			&i.BillingStartDate,
			&i.BillingEndDate,
			&i.TotalAmountDue,
			&i.TotalCalls,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.BillingCreatedAt,
			&i.SubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBillingHistoryBySubId = `-- name: GetBillingHistoryBySubId :many
SELECT billing_id, billing_start_date, billing_end_date, total_amount_due, total_calls, payment_status, payment_date, billing_created_at, subscription_id FROM billing_history
WHERE subscription_id = $1
LIMIT $2 OFFSET $3
`

type GetBillingHistoryBySubIdParams struct {
	SubscriptionID int32 `json:"subscription_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) GetBillingHistoryBySubId(ctx context.Context, arg GetBillingHistoryBySubIdParams) ([]BillingHistory, error) {
	rows, err := q.db.Query(ctx, getBillingHistoryBySubId, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingHistory{}
	for rows.Next() {
		var i BillingHistory
		if err := rows.Scan(
			&i.BillingID,
			&i.BillingStartDate,
			&i.BillingEndDate,
			&i.TotalAmountDue,
			&i.TotalCalls,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.BillingCreatedAt,
			&i.SubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMonthlyBillingRecords = `-- name: InsertMonthlyBillingRecords :exec
INSERT INTO billing_history (
  billing_start_date,
  billing_end_date,
  total_amount_due,
  total_calls,
  billing_created_at,
  subscription_id
)
SELECT
  EXTRACT(EPOCH FROM date_trunc('month', NOW() - INTERVAL '1 month'))::INTEGER AS billing_start_date,
  EXTRACT(EPOCH FROM date_trunc('month', NOW()))::INTEGER AS billing_end_date,
  COALESCE(SUM(a.total_cost), 0) AS total_amount_due,
  COALESCE(SUM(a.total_calls), 0) AS total_calls,
  EXTRACT(EPOCH FROM NOW())::INTEGER AS billing_created_at,
  a.subscription_id
FROM
  api_usage_summary a
WHERE
  TO_TIMESTAMP(a.usage_start_date) >= date_trunc('month', NOW() - INTERVAL '1 month')
  AND TO_TIMESTAMP(a.usage_start_date) < date_trunc('month', NOW())
GROUP BY
  a.subscription_id
ON CONFLICT DO NOTHING
`

// INSERT monthly billing records for subscriptions that had usage last month
func (q *Queries) InsertMonthlyBillingRecords(ctx context.Context) error {
	_, err := q.db.Exec(ctx, insertMonthlyBillingRecords)
	return err
}
