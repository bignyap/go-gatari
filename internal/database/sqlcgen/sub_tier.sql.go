// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sub_tier.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveExistingSubscriptionTier = `-- name: ArchiveExistingSubscriptionTier :exec
UPDATE subscription_tier
SET tier_archived = TRUE
WHERE tier_name = $1
`

func (q *Queries) ArchiveExistingSubscriptionTier(ctx context.Context, tierName string) error {
	_, err := q.db.Exec(ctx, archiveExistingSubscriptionTier, tierName)
	return err
}

const createSubscriptionTier = `-- name: CreateSubscriptionTier :one
INSERT INTO subscription_tier (
    tier_name, tier_description, tier_created_at, tier_updated_at
)
VALUES ($1, $2, $3, $4)
RETURNING subscription_tier_id
`

type CreateSubscriptionTierParams struct {
	TierName        string      `json:"tier_name"`
	TierDescription pgtype.Text `json:"tier_description"`
	TierCreatedAt   int32       `json:"tier_created_at"`
	TierUpdatedAt   int32       `json:"tier_updated_at"`
}

func (q *Queries) CreateSubscriptionTier(ctx context.Context, arg CreateSubscriptionTierParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSubscriptionTier,
		arg.TierName,
		arg.TierDescription,
		arg.TierCreatedAt,
		arg.TierUpdatedAt,
	)
	var subscription_tier_id int32
	err := row.Scan(&subscription_tier_id)
	return subscription_tier_id, err
}

type CreateSubscriptionTiersParams struct {
	TierName        string      `json:"tier_name"`
	TierDescription pgtype.Text `json:"tier_description"`
	TierCreatedAt   int32       `json:"tier_created_at"`
	TierUpdatedAt   int32       `json:"tier_updated_at"`
}

const deleteSubscriptionTierById = `-- name: DeleteSubscriptionTierById :exec
DELETE FROM subscription_tier
WHERE subscription_tier_id = $1
`

func (q *Queries) DeleteSubscriptionTierById(ctx context.Context, subscriptionTierID int32) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionTierById, subscriptionTierID)
	return err
}

const listSubscriptionTier = `-- name: ListSubscriptionTier :many
SELECT subscription_tier_id, tier_name, tier_archived, tier_description, tier_created_at, tier_updated_at, COUNT(subscription_tier_id) OVER() AS total_items  
FROM subscription_tier
WHERE tier_archived = $1
ORDER BY subscription_tier_id DESC
LIMIT $2 OFFSET $3
`

type ListSubscriptionTierParams struct {
	TierArchived bool  `json:"tier_archived"`
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
}

type ListSubscriptionTierRow struct {
	SubscriptionTierID int32       `json:"subscription_tier_id"`
	TierName           string      `json:"tier_name"`
	TierArchived       bool        `json:"tier_archived"`
	TierDescription    pgtype.Text `json:"tier_description"`
	TierCreatedAt      int32       `json:"tier_created_at"`
	TierUpdatedAt      int32       `json:"tier_updated_at"`
	TotalItems         int64       `json:"total_items"`
}

func (q *Queries) ListSubscriptionTier(ctx context.Context, arg ListSubscriptionTierParams) ([]ListSubscriptionTierRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionTier, arg.TierArchived, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionTierRow{}
	for rows.Next() {
		var i ListSubscriptionTierRow
		if err := rows.Scan(
			&i.SubscriptionTierID,
			&i.TierName,
			&i.TierArchived,
			&i.TierDescription,
			&i.TierCreatedAt,
			&i.TierUpdatedAt,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
