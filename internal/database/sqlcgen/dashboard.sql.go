// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dashboard.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const endpointUsagePerOrganization = `-- name: EndpointUsagePerOrganization :many

SELECT
  o.organization_name,
  a.api_endpoint_id,
  e.endpoint_name,
  SUM(a.total_calls) AS monthly_calls
FROM
  api_usage_summary a
JOIN
  organization o ON o.organization_id = a.organization_id
JOIN
  api_endpoint e ON e.api_endpoint_id = a.api_endpoint_id
WHERE
  TO_TIMESTAMP(a.usage_start_date) >= DATE_TRUNC('month', NOW())
  AND TO_TIMESTAMP(a.usage_start_date) < DATE_TRUNC('month', NOW()) + INTERVAL '1 month'
GROUP BY
  o.organization_name, a.api_endpoint_id, e.endpoint_name
ORDER BY
  monthly_calls DESC
`

type EndpointUsagePerOrganizationRow struct {
	OrganizationName string
	ApiEndpointID    int32
	EndpointName     string
	MonthlyCalls     int64
}

func (q *Queries) EndpointUsagePerOrganization(ctx context.Context) ([]EndpointUsagePerOrganizationRow, error) {
	rows, err := q.db.Query(ctx, endpointUsagePerOrganization)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EndpointUsagePerOrganizationRow{}
	for rows.Next() {
		var i EndpointUsagePerOrganizationRow
		if err := rows.Scan(
			&i.OrganizationName,
			&i.ApiEndpointID,
			&i.EndpointName,
			&i.MonthlyCalls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuotaUsageBySubscriptionID = `-- name: GetQuotaUsageBySubscriptionID :one
SELECT subscription_id, subscription_name, subscription_api_limit, subscription_quota_reset_interval, subscription_billing_model, subscription_billing_interval, costs_used, counts_used, calls_remaining, quota_exceeded
FROM v_subscription_quota_usage
WHERE subscription_id = $1
`

func (q *Queries) GetQuotaUsageBySubscriptionID(ctx context.Context, subscriptionID int32) (VSubscriptionQuotaUsage, error) {
	row := q.db.QueryRow(ctx, getQuotaUsageBySubscriptionID, subscriptionID)
	var i VSubscriptionQuotaUsage
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionName,
		&i.SubscriptionApiLimit,
		&i.SubscriptionQuotaResetInterval,
		&i.SubscriptionBillingModel,
		&i.SubscriptionBillingInterval,
		&i.CostsUsed,
		&i.CountsUsed,
		&i.CallsRemaining,
		&i.QuotaExceeded,
	)
	return i, err
}

const getSubscriptionQuotaUsage = `-- name: GetSubscriptionQuotaUsage :many
SELECT subscription_id, subscription_name, subscription_api_limit, subscription_quota_reset_interval, subscription_billing_model, subscription_billing_interval, costs_used, counts_used, calls_remaining, quota_exceeded FROM v_subscription_quota_usage WHERE quota_exceeded = true
`

func (q *Queries) GetSubscriptionQuotaUsage(ctx context.Context) ([]VSubscriptionQuotaUsage, error) {
	rows, err := q.db.Query(ctx, getSubscriptionQuotaUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VSubscriptionQuotaUsage{}
	for rows.Next() {
		var i VSubscriptionQuotaUsage
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.SubscriptionApiLimit,
			&i.SubscriptionQuotaResetInterval,
			&i.SubscriptionBillingModel,
			&i.SubscriptionBillingInterval,
			&i.CostsUsed,
			&i.CountsUsed,
			&i.CallsRemaining,
			&i.QuotaExceeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTierLevelMonthlyUsage = `-- name: GetTierLevelMonthlyUsage :many

SELECT
  t.subscription_tier_id,
  t.tier_name,
  DATE_TRUNC('month', TO_TIMESTAMP(a.usage_start_date)) AS usage_month,
  SUM(a.total_calls) AS total_calls,
  SUM(a.total_cost) AS total_revenue,
  COUNT(DISTINCT s.subscription_id) AS active_subscriptions
FROM
  api_usage_summary a
JOIN
  subscription s ON s.subscription_id = a.subscription_id
JOIN
  subscription_tier t ON t.subscription_tier_id = s.subscription_tier_id
WHERE
  TO_TIMESTAMP(a.usage_start_date) >= DATE_TRUNC('month', NOW() - INTERVAL '1 month')
  AND TO_TIMESTAMP(a.usage_start_date) < DATE_TRUNC('month', NOW())
GROUP BY
  t.subscription_tier_id, t.tier_name, usage_month
ORDER BY
  usage_month DESC, t.tier_name
`

type GetTierLevelMonthlyUsageRow struct {
	SubscriptionTierID  int32
	TierName            string
	UsageMonth          pgtype.Interval
	TotalCalls          int64
	TotalRevenue        int64
	ActiveSubscriptions int64
}

func (q *Queries) GetTierLevelMonthlyUsage(ctx context.Context) ([]GetTierLevelMonthlyUsageRow, error) {
	rows, err := q.db.Query(ctx, getTierLevelMonthlyUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTierLevelMonthlyUsageRow{}
	for rows.Next() {
		var i GetTierLevelMonthlyUsageRow
		if err := rows.Scan(
			&i.SubscriptionTierID,
			&i.TierName,
			&i.UsageMonth,
			&i.TotalCalls,
			&i.TotalRevenue,
			&i.ActiveSubscriptions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
