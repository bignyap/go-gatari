// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscription.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscription (
    subscription_name, subscription_type, subscription_created_date,
    subscription_updated_date, subscription_start_date, subscription_api_limit, 
    subscription_expiry_date, subscription_description, subscription_status, 
    organization_id, subscription_tier_id, 
    subscription_billing_interval, subscription_billing_model, subscription_quota_reset_interval
) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING subscription_id
`

type CreateSubscriptionParams struct {
	SubscriptionName               string
	SubscriptionType               string
	SubscriptionCreatedDate        int32
	SubscriptionUpdatedDate        int32
	SubscriptionStartDate          int32
	SubscriptionApiLimit           pgtype.Int4
	SubscriptionExpiryDate         pgtype.Int4
	SubscriptionDescription        pgtype.Text
	SubscriptionStatus             pgtype.Bool
	OrganizationID                 int32
	SubscriptionTierID             int32
	SubscriptionBillingInterval    pgtype.Text
	SubscriptionBillingModel       pgtype.Text
	SubscriptionQuotaResetInterval pgtype.Text
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.SubscriptionName,
		arg.SubscriptionType,
		arg.SubscriptionCreatedDate,
		arg.SubscriptionUpdatedDate,
		arg.SubscriptionStartDate,
		arg.SubscriptionApiLimit,
		arg.SubscriptionExpiryDate,
		arg.SubscriptionDescription,
		arg.SubscriptionStatus,
		arg.OrganizationID,
		arg.SubscriptionTierID,
		arg.SubscriptionBillingInterval,
		arg.SubscriptionBillingModel,
		arg.SubscriptionQuotaResetInterval,
	)
	var subscription_id int32
	err := row.Scan(&subscription_id)
	return subscription_id, err
}

type CreateSubscriptionsParams struct {
	SubscriptionName               string
	SubscriptionType               string
	SubscriptionCreatedDate        int32
	SubscriptionUpdatedDate        int32
	SubscriptionStartDate          int32
	SubscriptionApiLimit           pgtype.Int4
	SubscriptionExpiryDate         pgtype.Int4
	SubscriptionDescription        pgtype.Text
	SubscriptionStatus             pgtype.Bool
	OrganizationID                 int32
	SubscriptionTierID             int32
	SubscriptionBillingInterval    pgtype.Text
	SubscriptionBillingModel       pgtype.Text
	SubscriptionQuotaResetInterval pgtype.Text
}

const deleteSubscriptionById = `-- name: DeleteSubscriptionById :exec
DELETE FROM subscription
WHERE subscription_id = $1
`

func (q *Queries) DeleteSubscriptionById(ctx context.Context, subscriptionID int32) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionById, subscriptionID)
	return err
}

const deleteSubscriptionByOrgId = `-- name: DeleteSubscriptionByOrgId :exec
DELETE FROM subscription
WHERE organization_id = $1
`

func (q *Queries) DeleteSubscriptionByOrgId(ctx context.Context, organizationID int32) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionByOrgId, organizationID)
	return err
}

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT
  subscription_id AS id,
  organization_id,
  subscription_api_limit AS api_limit,
  subscription_expiry_date AS expiry_timestamp,
  subscription_status AS active
FROM subscription
WHERE organization_id = $1
  AND subscription_status = TRUE
`

type GetActiveSubscriptionRow struct {
	ID              int32
	OrganizationID  int32
	ApiLimit        pgtype.Int4
	ExpiryTimestamp pgtype.Int4
	Active          pgtype.Bool
}

func (q *Queries) GetActiveSubscription(ctx context.Context, organizationID int32) (GetActiveSubscriptionRow, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, organizationID)
	var i GetActiveSubscriptionRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ApiLimit,
		&i.ExpiryTimestamp,
		&i.Active,
	)
	return i, err
}

const getSubscriptionById = `-- name: GetSubscriptionById :one
SELECT 
    subscription.subscription_id, subscription.subscription_name, subscription.subscription_type, subscription.subscription_created_date, subscription.subscription_updated_date, subscription.subscription_start_date, subscription.subscription_api_limit, subscription.subscription_expiry_date, subscription.subscription_description, subscription.subscription_status, subscription.organization_id, subscription.subscription_tier_id, subscription.subscription_quota_reset_interval, subscription.subscription_billing_model, subscription.subscription_billing_interval, subscription_tier.tier_name  
FROM subscription
INNER JOIN subscription_tier ON subscription.subscription_tier_id = subscription_tier.subscription_tier_id
WHERE subscription.subscription_id = $1
`

type GetSubscriptionByIdRow struct {
	SubscriptionID                 int32
	SubscriptionName               string
	SubscriptionType               string
	SubscriptionCreatedDate        int32
	SubscriptionUpdatedDate        int32
	SubscriptionStartDate          int32
	SubscriptionApiLimit           pgtype.Int4
	SubscriptionExpiryDate         pgtype.Int4
	SubscriptionDescription        pgtype.Text
	SubscriptionStatus             pgtype.Bool
	OrganizationID                 int32
	SubscriptionTierID             int32
	SubscriptionQuotaResetInterval pgtype.Text
	SubscriptionBillingModel       pgtype.Text
	SubscriptionBillingInterval    pgtype.Text
	TierName                       string
}

func (q *Queries) GetSubscriptionById(ctx context.Context, subscriptionID int32) (GetSubscriptionByIdRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionById, subscriptionID)
	var i GetSubscriptionByIdRow
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionName,
		&i.SubscriptionType,
		&i.SubscriptionCreatedDate,
		&i.SubscriptionUpdatedDate,
		&i.SubscriptionStartDate,
		&i.SubscriptionApiLimit,
		&i.SubscriptionExpiryDate,
		&i.SubscriptionDescription,
		&i.SubscriptionStatus,
		&i.OrganizationID,
		&i.SubscriptionTierID,
		&i.SubscriptionQuotaResetInterval,
		&i.SubscriptionBillingModel,
		&i.SubscriptionBillingInterval,
		&i.TierName,
	)
	return i, err
}

const getSubscriptionByOrgId = `-- name: GetSubscriptionByOrgId :many
SELECT 
    subscription.subscription_id, subscription.subscription_name, subscription.subscription_type, subscription.subscription_created_date, subscription.subscription_updated_date, subscription.subscription_start_date, subscription.subscription_api_limit, subscription.subscription_expiry_date, subscription.subscription_description, subscription.subscription_status, subscription.organization_id, subscription.subscription_tier_id, subscription.subscription_quota_reset_interval, subscription.subscription_billing_model, subscription.subscription_billing_interval, subscription_tier.tier_name,
    COUNT(subscription.subscription_tier_id) OVER() AS total_items  
FROM subscription
INNER JOIN subscription_tier ON subscription.subscription_tier_id = subscription_tier.subscription_tier_id
WHERE subscription.organization_id = $1
LIMIT $2 OFFSET $3
`

type GetSubscriptionByOrgIdParams struct {
	OrganizationID int32
	Limit          int32
	Offset         int32
}

type GetSubscriptionByOrgIdRow struct {
	SubscriptionID                 int32
	SubscriptionName               string
	SubscriptionType               string
	SubscriptionCreatedDate        int32
	SubscriptionUpdatedDate        int32
	SubscriptionStartDate          int32
	SubscriptionApiLimit           pgtype.Int4
	SubscriptionExpiryDate         pgtype.Int4
	SubscriptionDescription        pgtype.Text
	SubscriptionStatus             pgtype.Bool
	OrganizationID                 int32
	SubscriptionTierID             int32
	SubscriptionQuotaResetInterval pgtype.Text
	SubscriptionBillingModel       pgtype.Text
	SubscriptionBillingInterval    pgtype.Text
	TierName                       string
	TotalItems                     int64
}

func (q *Queries) GetSubscriptionByOrgId(ctx context.Context, arg GetSubscriptionByOrgIdParams) ([]GetSubscriptionByOrgIdRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionByOrgId, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionByOrgIdRow{}
	for rows.Next() {
		var i GetSubscriptionByOrgIdRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.SubscriptionType,
			&i.SubscriptionCreatedDate,
			&i.SubscriptionUpdatedDate,
			&i.SubscriptionStartDate,
			&i.SubscriptionApiLimit,
			&i.SubscriptionExpiryDate,
			&i.SubscriptionDescription,
			&i.SubscriptionStatus,
			&i.OrganizationID,
			&i.SubscriptionTierID,
			&i.SubscriptionQuotaResetInterval,
			&i.SubscriptionBillingModel,
			&i.SubscriptionBillingInterval,
			&i.TierName,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscription = `-- name: ListSubscription :many
SELECT 
    subscription.subscription_id, subscription.subscription_name, subscription.subscription_type, subscription.subscription_created_date, subscription.subscription_updated_date, subscription.subscription_start_date, subscription.subscription_api_limit, subscription.subscription_expiry_date, subscription.subscription_description, subscription.subscription_status, subscription.organization_id, subscription.subscription_tier_id, subscription.subscription_quota_reset_interval, subscription.subscription_billing_model, subscription.subscription_billing_interval, subscription_tier.tier_name, 
    COUNT(subscription.subscription_tier_id) OVER() AS total_items  
FROM subscription
INNER JOIN subscription_tier ON subscription.subscription_tier_id = subscription_tier.subscription_tier_id
ORDER BY subscription.subscription_tier_id DESC
LIMIT $1 OFFSET $2
`

type ListSubscriptionParams struct {
	Limit  int32
	Offset int32
}

type ListSubscriptionRow struct {
	SubscriptionID                 int32
	SubscriptionName               string
	SubscriptionType               string
	SubscriptionCreatedDate        int32
	SubscriptionUpdatedDate        int32
	SubscriptionStartDate          int32
	SubscriptionApiLimit           pgtype.Int4
	SubscriptionExpiryDate         pgtype.Int4
	SubscriptionDescription        pgtype.Text
	SubscriptionStatus             pgtype.Bool
	OrganizationID                 int32
	SubscriptionTierID             int32
	SubscriptionQuotaResetInterval pgtype.Text
	SubscriptionBillingModel       pgtype.Text
	SubscriptionBillingInterval    pgtype.Text
	TierName                       string
	TotalItems                     int64
}

func (q *Queries) ListSubscription(ctx context.Context, arg ListSubscriptionParams) ([]ListSubscriptionRow, error) {
	rows, err := q.db.Query(ctx, listSubscription, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionRow{}
	for rows.Next() {
		var i ListSubscriptionRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionName,
			&i.SubscriptionType,
			&i.SubscriptionCreatedDate,
			&i.SubscriptionUpdatedDate,
			&i.SubscriptionStartDate,
			&i.SubscriptionApiLimit,
			&i.SubscriptionExpiryDate,
			&i.SubscriptionDescription,
			&i.SubscriptionStatus,
			&i.OrganizationID,
			&i.SubscriptionTierID,
			&i.SubscriptionQuotaResetInterval,
			&i.SubscriptionBillingModel,
			&i.SubscriptionBillingInterval,
			&i.TierName,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :execresult
UPDATE subscription
SET 
    subscription_name = $1,
    subscription_start_date = $2,
    subscription_api_limit = $3,
    subscription_expiry_date = $4,
    subscription_description = $5,
    subscription_status = $6,
    organization_id = $7,
    subscription_tier_id = $8,
    subscription_billing_interval = $9, 
    subscription_billing_model = $10, 
    subscription_quota_reset_interval = $11
WHERE subscription_id = $12
`

type UpdateSubscriptionParams struct {
	SubscriptionName               string
	SubscriptionStartDate          int32
	SubscriptionApiLimit           pgtype.Int4
	SubscriptionExpiryDate         pgtype.Int4
	SubscriptionDescription        pgtype.Text
	SubscriptionStatus             pgtype.Bool
	OrganizationID                 int32
	SubscriptionTierID             int32
	SubscriptionBillingInterval    pgtype.Text
	SubscriptionBillingModel       pgtype.Text
	SubscriptionQuotaResetInterval pgtype.Text
	SubscriptionID                 int32
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateSubscription,
		arg.SubscriptionName,
		arg.SubscriptionStartDate,
		arg.SubscriptionApiLimit,
		arg.SubscriptionExpiryDate,
		arg.SubscriptionDescription,
		arg.SubscriptionStatus,
		arg.OrganizationID,
		arg.SubscriptionTierID,
		arg.SubscriptionBillingInterval,
		arg.SubscriptionBillingModel,
		arg.SubscriptionQuotaResetInterval,
		arg.SubscriptionID,
	)
}
