// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: gatekeeping.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT
  subscription_id AS id,
  organization_id,
  subscription_api_limit AS api_limit,
  subscription_expiry_date AS expiry_timestamp,
  subscription_status AS active
FROM subscription
WHERE organization_id = $1
  AND subscription_status = TRUE
  AND EXISTS (
    SELECT 1 FROM tier_base_pricing tbp
    WHERE tbp.subscription_tier_id = subscription.subscription_tier_id
      AND tbp.api_endpoint_id = $2
  )
`

type GetActiveSubscriptionParams struct {
	OrganizationID int32
	ApiEndpointID  int32
}

type GetActiveSubscriptionRow struct {
	ID              int32
	OrganizationID  int32
	ApiLimit        pgtype.Int4
	ExpiryTimestamp pgtype.Int4
	Active          pgtype.Bool
}

func (q *Queries) GetActiveSubscription(ctx context.Context, arg GetActiveSubscriptionParams) (GetActiveSubscriptionRow, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, arg.OrganizationID, arg.ApiEndpointID)
	var i GetActiveSubscriptionRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ApiLimit,
		&i.ExpiryTimestamp,
		&i.Active,
	)
	return i, err
}

const getEndpointByName = `-- name: GetEndpointByName :one
SELECT
  api_endpoint_id AS id,
  endpoint_name AS name
FROM api_endpoint
WHERE endpoint_name = $1
`

type GetEndpointByNameRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetEndpointByName(ctx context.Context, endpointName string) (GetEndpointByNameRow, error) {
	row := q.db.QueryRow(ctx, getEndpointByName, endpointName)
	var i GetEndpointByNameRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getOrganizationByName = `-- name: GetOrganizationByName :one
SELECT
  organization_id AS id,
  organization_name AS name
FROM organization
WHERE organization_name = $1 AND organization_active = TRUE
`

type GetOrganizationByNameRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetOrganizationByName(ctx context.Context, organizationName string) (GetOrganizationByNameRow, error) {
	row := q.db.QueryRow(ctx, getOrganizationByName, organizationName)
	var i GetOrganizationByNameRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getPricing = `-- name: GetPricing :one
SELECT
  COALESCE(cep.custom_cost_per_call, tbp.base_cost_per_call) AS cost_per_call
FROM subscription
JOIN tier_base_pricing tbp
  ON subscription.subscription_tier_id = tbp.subscription_tier_id
  AND tbp.api_endpoint_id = $2
LEFT JOIN custom_endpoint_pricing cep
  ON cep.subscription_id = subscription.subscription_id
  AND cep.tier_base_pricing_id = tbp.tier_base_pricing_id
WHERE subscription.subscription_id = $1
`

type GetPricingParams struct {
	SubscriptionID int32
	ApiEndpointID  int32
}

func (q *Queries) GetPricing(ctx context.Context, arg GetPricingParams) (float64, error) {
	row := q.db.QueryRow(ctx, getPricing, arg.SubscriptionID, arg.ApiEndpointID)
	var cost_per_call float64
	err := row.Scan(&cost_per_call)
	return cost_per_call, err
}

const incrementUsage = `-- name: IncrementUsage :exec
INSERT INTO api_usage_summary (
  usage_start_date, usage_end_date, total_calls, total_cost,
  subscription_id, api_endpoint_id, organization_id
)
VALUES (
  FLOOR(EXTRACT(EPOCH FROM now())/60)*60,
  FLOOR(EXTRACT(EPOCH FROM now())/60)*60 + 59,
  1, 0.0, $1, $2, $3
)
ON CONFLICT (usage_start_date, usage_end_date, api_endpoint_id, organization_id)
DO UPDATE SET total_calls = api_usage_summary.total_calls + 1
`

type IncrementUsageParams struct {
	SubscriptionID int32
	ApiEndpointID  int32
	OrganizationID int32
}

func (q *Queries) IncrementUsage(ctx context.Context, arg IncrementUsageParams) error {
	_, err := q.db.Exec(ctx, incrementUsage, arg.SubscriptionID, arg.ApiEndpointID, arg.OrganizationID)
	return err
}
